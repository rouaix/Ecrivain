<h2>Carte mentale : {{ @project.title }}</h2>
<a class="button" href="{{ @base }}/project/{{ @project.id }}"><i class="fas fa-arrow-left"></i> Retour au projet</a>
<div id="mindmap" class="mindmap-canvas"></div>
<p class="mindmap-guide">
    <strong class="mindmap-guide__title">Guide :</strong>
    Projet (Noir) • Actes (Orange) • Chapitres (Rose) • Personnages (Bleu) • Elements (Vert) — <span
        class="mindmap-guide__muted">Zoom &
        Pan
        disponibles</span>
</p>

<!-- Content Popup -->
<div id="node-popup" class="popup-overlay">
    <div class="popup-content">
        <span id="closePopupBtn" class="popup-close">&times;</span>
        <h3 id="popup-title"></h3>
        <div id="popup-body"></div>
    </div>
</div>

<script nonce="{{ @nonce }}" src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
<script nonce="{{ @nonce }}">
    var rawData = {{ @mindmapData | raw }};

    // Safety Check
    if (!rawData || !rawData.nodes || !rawData.links) {
        d3.select('#mindmap').html('<p class="mindmap-error">Erreur de chargement des donnees.</p>');
    }

    // --- 1. Data Transformation: Flat -> Hierarchy ---
    var nodesMap = {};
    rawData.nodes.forEach(n => {
        n.children = [];
        n._children = []; // For collapse state storage
        nodesMap[n.id] = n;
    });

    // Identify Root (Project)
    var rootNode = rawData.nodes.find(n => n.type === 'project');
    if (!rootNode) rootNode = rawData.nodes[0]; // Fallback

    // Build Hierarchy
    rawData.links.forEach(l => {
        var parentId = (typeof l.source === 'object') ? l.source.id : l.source;
        var childId = (typeof l.target === 'object') ? l.target.id : l.target;

        var parent = nodesMap[parentId];
        var child = nodesMap[childId];

        if (parent && child) {
            parent.children.push(child);
            child.parent = parent;
        }
    });

    // Separation: Characters vs Content
    var rightChildren = [];
    var leftChildren = [];

    if (rootNode.children) {
        rootNode.children.forEach(child => {
            if (child.type === 'character') {
                leftChildren.push(child);
            } else {
                rightChildren.push(child);
            }
        });
    }

    // --- 2. Setup D3 Tree ---
    var containerDiv = document.getElementById('mindmap');
    var width = containerDiv.clientWidth || 1000;
    var height = containerDiv.clientHeight || 800;

    var svg = d3.select('#mindmap').html('').append('svg')
        .attr('width', '100%')
        .attr('height', '100%')
        .attr('viewBox', [-width / 2, -height / 2, width, height]);

    var gContainer = svg.append('g');

    // Create Layers to ensure Links are always behind Nodes
    var gLinksLayer = gContainer.append('g').attr('class', 'links-layer');
    var gNodesLayer = gContainer.append('g').attr('class', 'nodes-layer');

    // Zoom
    svg.call(d3.zoom().scaleExtent([0.1, 3]).on('zoom', e => {
        gContainer.attr('transform', e.transform);
    }));

    // Tree Layout
    var treeLayout = d3.tree().nodeSize([70, 200]);

    // Convert to D3 Hierarchy
    var root = d3.hierarchy(rootNode, d => d.children);

    // Styling
    const COLORS = {
        project: '#202124',
        act: '#EF6C00',
        chapter: '#E91E63',
        character: '#1976D2',
        element: '#2E7D32',
        element_group: '#66BB6A',
        note_group: '#7E57C2',
        note: '#9575CD',
        section: '#00897B',
        section_group: '#26A69A',
        character_group: '#42A5F5',
        default: '#5f6368',
        background: '#ffffff',
        text: '#3c4043',
        link: '#e0e0e0'
    };

    // Collapse logic initialization
    function collapse(d) {
        if (d.children) {
            d._children = d.children;
            d._children.forEach(collapse);
            d.children = null;
        }
    }

    // Collapse all descendants of root initially
    if (root.children) {
        root.children.forEach(collapse);
    }

    var i = 0;
    update(root);

    function update(source) {

        treeLayout(root);

        // --- 1. Measure Widths & Assign Sides ---
        var canvas = document.createElement('canvas');
        var context = canvas.getContext('2d');
        context.font = "500 14px 'Google Sans', Roboto, sans-serif";

        var leftDepths = {};
        var rightDepths = {};

        root.descendants().forEach(d => {
            var textWidth = 0;
            // Root node (project) has special width calculation for multiline content
            if (d.depth === 0) {
                context.font = "bold 16px 'Google Sans', Roboto, sans-serif";
                var nameWidth = context.measureText(d.data.name).width;
                textWidth = nameWidth;
                if (d.data.description) {
                    context.font = "italic 12px 'Google Sans', Roboto, sans-serif";
                    var desc = d.data.description.substring(0, 50);
                    var descWidth = context.measureText(desc).width;
                    textWidth = Math.max(textWidth, descWidth);
                }
                if (d.data.author) {
                    context.font = "12px 'Google Sans', Roboto, sans-serif";
                    var authorWidth = context.measureText('par ' + d.data.author).width;
                    textWidth = Math.max(textWidth, authorWidth);
                }
            } else {
                context.font = "500 14px 'Google Sans', Roboto, sans-serif";
                textWidth = context.measureText(d.data.name).width;
                if ((d.data.type === 'act' || d.data.type === 'chapter') && d.data.description) {
                    context.font = "italic 11px 'Google Sans', Roboto, sans-serif";
                    var descWidth = context.measureText(d.data.description).width;
                    textWidth = Math.max(textWidth, descWidth);
                }
            }
            // Add extra space for content icon if node has content
            var hasContent = d.data.content && d.data.content.trim().length > 0;
            var contentIconSpace = hasContent ? 25 : 0;
            var requiredWidth = textWidth + 80 + contentIconSpace;
            d.rawWidth = requiredWidth;

            var ancestor = d;
            while (ancestor.parent && ancestor.parent !== root) {
                ancestor = ancestor.parent;
            }

            if (d.depth === 0) {
                d.side = 'root';
                rightDepths[0] = Math.max(rightDepths[0] || 0, requiredWidth / 2);
                leftDepths[0] = Math.max(leftDepths[0] || 0, requiredWidth / 2);
            } else if (['character', 'note', 'character_group', 'note_group'].includes(ancestor.data.type)) {
                d.side = 'left';
                leftDepths[d.depth] = Math.max(leftDepths[d.depth] || 0, requiredWidth);
            } else {
                d.side = 'right';
                rightDepths[d.depth] = Math.max(rightDepths[d.depth] || 0, requiredWidth);
            }
        });

        // --- 1.5. Standardize Widths per Column ---
        root.descendants().forEach(d => {
            if (d.depth > 0) {
                if (d.side === 'left') {
                    d.width = leftDepths[d.depth];
                } else {
                    d.width = rightDepths[d.depth];
                }
            } else {
                d.width = d.rawWidth;
            }
        });

        // --- 2. Calculate Horizontal Positions (Y) per Depth ---
        var rightY = {};
        var leftY = {};

        rightY[0] = 0;
        leftY[0] = 0;

        var maxDepth = 0;
        root.descendants().forEach(d => maxDepth = Math.max(maxDepth, d.depth));

        for (var i = 1; i <= maxDepth; i++) {
            var prevWR = (i === 1) ? rightDepths[0] : rightDepths[i - 1];
            rightY[i] = rightY[i - 1] + prevWR + 60;

            var prevWL = (i === 1) ? leftDepths[0] : leftDepths[i - 1];
            leftY[i] = leftY[i - 1] + prevWL + 60;
        }

        // --- 3. Apply Positions ---
        root.descendants().forEach(d => {
            if (d.side === 'left') {
                d.y = -leftY[d.depth];
            } else if (d.side === 'right') {
                d.y = rightY[d.depth];
            } else {
                d.y = 0;
            }
        });

        var nodes = root.descendants();
        var links = root.links();

        // --- LINKS ---
        var link = gLinksLayer.selectAll('path.link')
            .data(links, d => d.target.id);

        var linkEnter = link.enter().append('path')
            .attr('class', 'link')
            .attr('fill', 'none')
            .attr('stroke', COLORS.link)
            .attr('stroke-width', 1.5);

        function getLinkPath(d) {
            var s = d.source;
            var t = d.target;

            var sx = s.x;
            var sy = s.y;

            if (s.side === 'root') {
                if (t.side === 'left') sy -= s.width / 2;
                else sy += s.width / 2;
            } else if (s.side === 'right') {
                sy += s.width;
            } else if (s.side === 'left') {
                sy -= s.width;
            }

            var tx = t.x;
            var ty = t.y;

            var midY = (sy + ty) / 2;
            return `M ${sy} ${sx} L ${midY} ${sx} L ${midY} ${tx} L ${ty} ${tx}`;
        }

        var linkUpdate = linkEnter.merge(link);
        linkUpdate.transition().duration(200).attr('d', getLinkPath);

        link.exit().transition().duration(200).remove();

        // --- NODES ---
        var node = gNodesLayer.selectAll('g.node')
            .data(nodes, d => d.data.id || (d.data.id = ++i));

        var nodeEnter = node.enter().append('g')
            .attr('class', 'node')
            .attr('transform', d => `translate(${source.y0 || root.y},${source.x0 || root.x})`)
            .on('click', click);

        nodeEnter.append('rect')
            .attr('rx', 20)
            .attr('ry', 20)
            .attr('stroke', '#dadce0')
            .attr('stroke-width', 1)
            .attr('fill', '#fff')
            .style('filter', 'drop-shadow(0 1px 2px rgba(60,64,67,0.3))');

        nodeEnter.append('circle')
            .attr('r', 5)
            .attr('class', 'indicator')
            .attr('fill', d => COLORS[d.data.type] || COLORS.default);

        nodeEnter.append('text')
            .attr('dy', '.35em')
            .attr('class', 'label')
            .style('font-family', 'Google Sans, Roboto, sans-serif')
            .style('font-size', '14px')
            .style('font-weight', '500')
            .style('fill', COLORS.text)
            .style('pointer-events', 'none');

        nodeEnter.append('text')
            .attr('class', 'collapse-icon')
            .attr('dy', '.35em')
            .style('font-size', '10px')
            .style('fill', '#5f6368')
            .style('cursor', 'pointer');

        var contentIconGroup = nodeEnter.append('g')
            .attr('class', 'content-icon')
            .style('cursor', 'pointer');

        contentIconGroup.append('ellipse')
            .attr('rx', 7)
            .attr('ry', 5)
            .attr('fill', 'none')
            .attr('class', 'eye-outline')
            .attr('stroke-width', 1.5);

        contentIconGroup.append('circle')
            .attr('r', 2.5)
            .attr('class', 'eye-pupil');

        var nodeUpdate = nodeEnter.merge(node);
        nodeUpdate.transition().duration(200)
            .attr('transform', d => `translate(${d.y},${d.x})`);

        nodeUpdate.each(function (d) {
            var g = d3.select(this);
            var isRoot = d.data.type === 'project';
            var hasDesc = (d.data.type === 'act' || d.data.type === 'chapter') && d.data.description;

            var w = d.width;
            var h = 56;

            if (isRoot) {
                h = 80;
                w = d.width;
            }

            var xPos = 0;
            if (d.side === 'root') xPos = -w / 2;
            else if (d.side === 'left') xPos = -w;

            g.select('rect')
                .attr('x', xPos)
                .attr('y', -h / 2)
                .attr('width', w)
                .attr('height', h)
                .attr('rx', isRoot ? 10 : 20)
                .attr('ry', isRoot ? 10 : 20)
                .attr('stroke', (d._children) ? (COLORS[d.data.type] || COLORS.default) : '#dadce0')
                .attr('stroke-width', (d._children || isRoot) ? 2 : 1);

            // Text Rendering
            var label = g.select('.label');
            label.selectAll('tspan').remove();  // ✅ Supprime tous les tspans existants
            label.text(null);

            if (isRoot) {
                label.append('tspan')
                    .attr('x', xPos + w / 2)
                    .attr('dy', '-1.2em')
                    .style('font-weight', 'bold')
                    .style('font-size', '16px')
                    .text(d.data.name);

                var desc = d.data.description || '';
                if (desc.length > 50) desc = desc.substring(0, 50) + '...';

                label.append('tspan')
                    .attr('x', xPos + w / 2)
                    .attr('dy', '1.4em')
                    .style('font-style', 'italic')
                    .style('font-size', '12px')
                    .style('fill', '#5f6368')
                    .text(desc);

                var auth = d.data.author || '';
                if (auth) {
                    label.append('tspan')
                        .attr('x', xPos + w / 2)
                        .attr('dy', '1.4em')
                        .style('font-weight', 'normal')
                        .style('font-size', '12px')
                        .style('fill', '#3c4043')
                        .text('par ' + auth);
                }

                label.attr('text-anchor', 'middle');
            } else if ((d.data.type === 'act' || d.data.type === 'chapter') && d.data.description) {
                label.append('tspan')
                    .attr('x', xPos + w / 2)
                    .attr('dy', '-0.4em')
                    .style('font-weight', '500')
                    .style('font-size', '14px')
                    .text(d.data.name);

                label.append('tspan')
                    .attr('x', xPos + w / 2)
                    .attr('dy', '1.3em')
                    .style('font-style', 'italic')
                    .style('font-size', '11px')
                    .style('fill', '#5f6368')
                    .text(d.data.description);

                label.attr('text-anchor', 'middle');
            } else {
                label.text(d.data.name)
                    .attr('x', xPos + w / 2)
                    .attr('dy', '.35em')
                    .attr('text-anchor', 'middle')
                    .style('font-weight', '500')
                    .style('font-size', '14px');
            }

            // Indicator (Left side of pill) - Hide for root
            g.select('.indicator')
                .attr('cx', xPos + 12)
                .attr('cy', 0)
                .style('display', isRoot ? 'none' : 'block');

            // Collapse Icon (Right side of pill)
            var icon = g.select('.collapse-icon');
            if ((d.children || d._children) && !isRoot) {
                icon.attr('x', xPos + w - 12)
                    .text(d._children ? '+' : '-')
                    .style('opacity', 1);
            } else {
                icon.style('opacity', 0);
            }

            // Content Indicator (shows if node has content to display)
            var contentIcon = g.select('.content-icon');
            var hasContent = d.data.content && d.data.content.trim().length > 0;
            var hasCollapse = (d.children || d._children) && !isRoot;
            var hasChildren = (d.children || d._children);

            // Only show eye icon on leaf nodes (nodes without children) that have content
            if (hasContent && !isRoot && !hasChildren) {
                // Position at the right with 5px margin
                var iconX = xPos + w - 21;
                var nodeColor = COLORS[d.data.type] || COLORS.default;

                contentIcon.attr('transform', 'translate(' + iconX + ', 0)')
                    .style('opacity', 1);

                // Apply node type color to eye icon
                contentIcon.select('.eye-outline').attr('stroke', nodeColor);
                contentIcon.select('.eye-pupil').attr('fill', nodeColor);
            } else {
                contentIcon.style('opacity', 0);
            }
        });

        // Hover
        nodeUpdate.on('mouseenter', function (e, d) {
            d3.select(this).select('rect').attr('stroke', COLORS[d.data.type]);

        }).on('mouseleave', function (e, d) {
            if (!d._children)
                d3.select(this).select('rect').attr('stroke', '#dadce0');
        });

        var nodeExit = node.exit().transition().duration(200)
            .attr('transform', d => `translate(${source.y},${source.x})`)
            .remove();

        nodeExit.select('rect').attr('fill-opacity', 0);
        nodeExit.select('text').style('fill-opacity', 0);

        nodes.forEach(d => {
            d.x0 = d.x;
            d.y0 = d.y;
        });
    }

    // Toggle children on click
    function click(event, d) {
        if (event.defaultPrevented) return;

        // Popup logic - show for content-heavy types (only on leaf nodes without children)
        var hasContent = d.data.content && d.data.content.trim() !== '';
        var popupTypes = ['character', 'note', 'section', 'element'];
        var isSubItem = d.data.is_subchapter || d.data.is_subelement;
        var hasChildren = d.children || d._children;

        if ((popupTypes.includes(d.data.type) || (d.data.type === 'chapter' && isSubItem)) && hasContent && !hasChildren) {
            showPopup(d.data);
            return;
        }

        // Collapse Logic
        if (d.children) {
            d._children = d.children;
            d.children = null;
        } else {
            d.children = d._children;
            d._children = null;
        }
        update(d);
    }

    function diagonal(s, d) {
        var midY = (s.y + d.y) / 2;
        return `M ${s.y} ${s.x}
                L ${midY} ${s.x}
                L ${midY} ${d.x}
                L ${d.y} ${d.x}`;
    }

    function showPopup(d) {
        document.getElementById('popup-title').innerText = d.name;
        document.getElementById('popup-body').innerHTML = d.content ? d.content : '<em>Pas de contenu.</em>';
        document.getElementById('node-popup').classList.add('is-visible');
    }

    function closePopup() {
        document.getElementById('node-popup').classList.remove('is-visible');
    }

    document.addEventListener('DOMContentLoaded', function () {
        const closeBtn = document.getElementById('closePopupBtn');
        if (closeBtn) closeBtn.addEventListener('click', closePopup);
    });

    window.onclick = function (event) {
        var modal = document.getElementById('node-popup');
        if (event.target == modal) {
            modal.classList.remove('is-visible');
        }
    }

</script>